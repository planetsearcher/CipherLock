"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at
  <root>/scripts/genabi.mjs. This script parses the
  <root>/packages/fhevm-hardhat-template/deployments directory to retrieve
  deployment information for SecureMessenger.sol:

  - <root>/packages/site/abi/abi/SecureMessengerABI.ts
  - <root>/packages/site/abi/abi/SecureMessengerAddresses.ts
*/
import { SecureMessengerAddresses } from "@/abi/SecureMessengerAddresses";
import { SecureMessengerABI } from "@/abi/SecureMessengerABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

export type SecureMessageType = {
  id: number;
  sender: string;
  recipient: string;
  content: string | null; // null if not decrypted
  transmissionTime: number;
  isDecrypted: boolean;
};

type SecureMessengerInfoType = {
  abi: typeof SecureMessengerABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves SecureMessenger contract metadata for the given EVM `chainId`.
 *
 * The ABI and address book are **generated** from the `fhevm-hardhat-template`
 * artifacts into the `@/abi` folder at build time. This function performs a
 * simple lookup in that generated map.
 *
 * Behavior:
 * - If `chainId` is `undefined` or not found in the map, returns ABI only.
 * - Otherwise returns `{ abi, address, chainId, chainName }`.
 *
 * @param chainId - Target chain id (e.g., 1, 5, 11155111). `undefined` returns ABI-only.
 * @returns Contract info for the chain or ABI-only fallback.
 * @example
 * const { abi, address } = getSecureMessengerByChainId(chainId);
 */
function getSecureMessengerByChainId(
  chainId: number | undefined
): SecureMessengerInfoType {
  if (!chainId) {
    return { abi: SecureMessengerABI.abi };
  }

  const entry =
    SecureMessengerAddresses[chainId.toString() as keyof typeof SecureMessengerAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: SecureMessengerABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: SecureMessengerABI.abi,
  };
}

/*
 * Main SecureMessenger React hook for encrypted confidential messages
 */
export const useSecureMessenger = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  //////////////////////////////////////////////////////////////////////////////
  // States + Refs (refs are mostly used to access latest React values and avoid
  // state dependencies). Consider @tanstack/react-query as an alternative to
  // handle async operations like FHEVM encryption/decryption
  //////////////////////////////////////////////////////////////////////////////

  const [messages, setMessages] = useState<SecureMessageType[]>([]);
  const [decryptedContents, setDecryptedContents] = useState<Map<number, string>>(new Map());
  const [totalTransmissions, setTotalTransmissions] = useState<number>(0);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isTransmitting, setIsTransmitting] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");

  const secureMessengerRef = useRef<SecureMessengerInfoType | undefined>(undefined);
  const isLoadingRef = useRef<boolean>(isLoading);
  const isTransmittingRef = useRef<boolean>(isTransmitting);
  const isDecryptingRef = useRef<boolean>(isDecrypting);

  //////////////////////////////////////////////////////////////////////////////
  // SecureMessenger Contract
  //////////////////////////////////////////////////////////////////////////////

  const secureMessenger = useMemo(() => {
    const c = getSecureMessengerByChainId(chainId);

    secureMessengerRef.current = c;

    if (!c.address) {
      setMessage(`SecureMessenger deployment not found for chainId=${chainId}.`);
    }

    return c;
  }, [chainId]);

  //////////////////////////////////////////////////////////////////////////////
  // Contract Instance
  //////////////////////////////////////////////////////////////////////////////

  const isDeployed = useMemo(() => {
    if (!secureMessenger) {
      return undefined;
    }
    return (Boolean(secureMessenger.address) && secureMessenger.address !== ethers.ZeroAddress);
  }, [secureMessenger]);

  const contractInstance = useMemo(() => {
    if (!secureMessenger.address || !ethersReadonlyProvider) {
      return undefined;
    }
    return new ethers.Contract(
      secureMessenger.address,
      secureMessenger.abi,
      ethersReadonlyProvider
    );
  }, [secureMessenger.address, secureMessenger.abi, ethersReadonlyProvider]);

  //////////////////////////////////////////////////////////////////////////////
  // Load Messages
  //////////////////////////////////////////////////////////////////////////////

  const loadMessages = useCallback(async () => {
    if (!contractInstance || isLoadingRef.current) {
      return;
    }

    isLoadingRef.current = true;
    setIsLoading(true);
    setMessage("Loading secure messages...");

    try {
      const total = await contractInstance.getTotalTransmissions();
      setTotalTransmissions(Number(total));

      const loadedMessages: SecureMessageType[] = [];

      // Load all messages (in a real app, you'd implement pagination)
      for (let i = 1; i <= Number(total); i++) {
        try {
          const [sender, recipient, transmissionTime] = await contractInstance.getTransmissionMetadata(i);
          loadedMessages.push({
            id: i,
            sender,
            recipient,
            content: null,
            transmissionTime: Number(transmissionTime),
            isDecrypted: false,
          });
        } catch (error) {
          console.error(`Failed to load message ${i}:`, error);
        }
      }

      setMessages(loadedMessages);
      setMessage(`Loaded ${loadedMessages.length} secure messages`);
    } catch (error) {
      setMessage("Failed to load secure messages");
      console.error("Load messages error:", error);
    } finally {
      isLoadingRef.current = false;
      setIsLoading(false);
    }
  }, [contractInstance]);

  // Auto load messages when contract is available
  useEffect(() => {
    loadMessages();
  }, [loadMessages]);

  //////////////////////////////////////////////////////////////////////////////
  // Transmit Secure Message
  //////////////////////////////////////////////////////////////////////////////

  const transmitSecureMessage = useCallback(
    async (recipientAddress: string, messageText: string) => {
      if (isTransmittingRef.current || !instance || !ethersSigner || !secureMessenger.address) {
        return;
      }

      if (!ethers.isAddress(recipientAddress)) {
        setMessage("Invalid recipient address");
        return;
      }

      if (recipientAddress.toLowerCase() === (await ethersSigner.getAddress()).toLowerCase()) {
        setMessage("Cannot transmit message to yourself");
        return;
      }

      const thisChainId = chainId;
      const thisSecureMessengerAddress = secureMessenger.address;
      const thisEthersSigner = ethersSigner;
      const thisContract = new ethers.Contract(
        thisSecureMessengerAddress,
        secureMessenger.abi,
        thisEthersSigner
      );

      isTransmittingRef.current = true;
      setIsTransmitting(true);
      setMessage("Preparing to transmit secure message...");

      const run = async () => {
        const isStale = () =>
          thisSecureMessengerAddress !== secureMessengerRef.current?.address ||
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          // Convert message text to bytes and then to number for encryption
          const messageBytes = ethers.toUtf8Bytes(messageText);
          const messageValue = BigInt(ethers.hexlify(messageBytes));

          setMessage("Creating encrypted input...");

          const input = instance.createEncryptedInput(
            thisSecureMessengerAddress,
            thisEthersSigner.address
          );
          input.add256(messageValue);

          // CPU-intensive operation
          const enc = await input.encrypt();

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          setMessage("Transmitting secure message to blockchain...");

          const tx: ethers.TransactionResponse = await thisContract.transmitSecureMessage(
            recipientAddress,
            enc.handles[0],
            enc.inputProof
          );

          setMessage(`Transaction submitted: ${tx.hash}`);

          const receipt = await tx.wait();

          setMessage(`Secure message transmitted! Block: ${receipt?.blockNumber}`);

          // Reload messages to include the new one
          await loadMessages();

        } catch (error) {
          setMessage("Failed to transmit secure message");
          console.error("Transmit secure message error:", error);
        } finally {
          isTransmittingRef.current = false;
          setIsTransmitting(false);
        }
      };

      await run();
    },
    [
      instance,
      ethersSigner,
      secureMessenger.address,
      secureMessenger.abi,
      chainId,
      sameChain,
      sameSigner,
      loadMessages,
    ]
  );

  //////////////////////////////////////////////////////////////////////////////
  // Decrypt Message
  //////////////////////////////////////////////////////////////////////////////

  const decryptMessage = useCallback(
    async (messageId: number) => {
      if (isDecryptingRef.current || !instance || !ethersSigner) {
        return;
      }

      const message = messages.find(m => m.id === messageId);
      if (!message) {
        setMessage("Message not found");
        return;
      }

      // Only recipient can decrypt
      const userAddress = await ethersSigner.getAddress();
      if (message.recipient.toLowerCase() !== userAddress.toLowerCase()) {
        setMessage("Only the recipient can decrypt this message");
        return;
      }

      const thisChainId = chainId;
      const thisEthersSigner = ethersSigner;
      const thisSecureMessengerAddress = secureMessenger.address;

      if (!thisSecureMessengerAddress) {
        setMessage("Contract address not available");
        return;
      }

      isDecryptingRef.current = true;
      setIsDecrypting(true);
      setMessage(`Decrypting message ${messageId}...`);

      const run = async () => {
        const isStale = () =>
          !sameChain.current(thisChainId) ||
          !sameSigner.current(thisEthersSigner);

        try {
          const sig: FhevmDecryptionSignature | null =
            await FhevmDecryptionSignature.loadOrSign(
              instance,
              [thisSecureMessengerAddress as `0x${string}`],
              ethersSigner,
              fhevmDecryptionSignatureStorage
            );

          if (!sig) {
            setMessage("Unable to build FHEVM decryption signature");
            return;
          }

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          setMessage("Calling FHEVM decryption...");

          const contract = new ethers.Contract(
            thisSecureMessengerAddress,
            secureMessenger.abi,
            ethersReadonlyProvider
          );

          const encryptedContent = await contract.getEncryptedPayload(messageId);

          // Get handle from euint256 object
          const handle = encryptedContent.handle || encryptedContent.toString();

          const res = await instance.userDecrypt(
            [{ handle: handle, contractAddress: thisSecureMessengerAddress }],
            sig.privateKey,
            sig.publicKey,
            sig.signature,
            sig.contractAddresses,
            sig.userAddress,
            sig.startTimestamp,
            sig.durationDays
          );

          if (isStale()) {
            setMessage("Operation cancelled");
            return;
          }

          // Convert decrypted bytes back to string
          const decryptedValue = res[handle];
          if (typeof decryptedValue === 'bigint') {
            const hexString = ethers.toBeHex(decryptedValue);
            const messageText = ethers.toUtf8String(hexString);
            setDecryptedContents(prev => new Map(prev.set(messageId, messageText)));
            setMessages(prev => prev.map(m =>
              m.id === messageId ? { ...m, content: messageText, isDecrypted: true } : m
            ));
            setMessage(`Message ${messageId} decrypted successfully!`);
          } else {
            setMessage("Failed to decrypt message: invalid format");
          }

        } catch (error) {
          setMessage(`Failed to decrypt message ${messageId}`);
          console.error("Decrypt message error:", error);
        } finally {
          isDecryptingRef.current = false;
          setIsDecrypting(false);
        }
      };

      await run();
    },
    [
      instance,
      ethersSigner,
      ethersReadonlyProvider,
      fhevmDecryptionSignatureStorage,
      secureMessenger.address,
      secureMessenger.abi,
      messages,
      chainId,
      sameChain,
      sameSigner,
    ]
  );

  return {
    contractAddress: secureMessenger.address,
    isDeployed,
    messages,
    totalTransmissions,
    isLoading,
    isTransmitting,
    isDecrypting,
    message,
    transmitSecureMessage,
    decryptMessage,
    loadMessages,
  };
};
